AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Get-StepFunction-Execution-time Lambda
  - 5分おきに Step Functions 実行中の経過秒を Datadog へ送信

Parameters:
  DatadogApiKey:
    Type: String
    NoEcho: true
    Description: Datadog API key (DD_API_KEY) – provided at stack deploy time
  DatadogDebugLog:
    Type: String
    AllowedValues: ["true", "false"]
    Default: "true"
    Description: Set DD_DEBUG_LOG environment variable
  DatadogSite:
    Type: String
    Default: ap1.datadoghq.com
    Description: Datadog site (DD_SITE)
  SetUnitSecond:
    Type: String
    AllowedValues: ["true", "false"]
    Default: "true"
    Description: Set SET_UNIT_SECOND environment variable (true to fix unit=second via DD app key if provided)
  MaxExecutionsPageSize:
    Type: Number
    Default: 1000
    Description: MAX_RESULTS for Step Functions list_executions (optional tuning parameter)
  LambdaTimeoutSeconds:
    Type: Number
    Default: 900
    Description: Lambda timeout in seconds (default 15 minutes)
  LambdaMemorySize:
    Type: Number
    Default: 128
    Description: Lambda memory size in MB

Resources:
  GetStepFunctionExecutionTimePolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      ManagedPolicyName: Get-StepFunction-Execution-time
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: ListStateMachines
            Effect: Allow
            Action: states:ListStateMachines
            Resource: "*"
          - Sid: ListTagsForResource
            Effect: Allow
            Action: states:ListTagsForResource
            Resource: "*"
          - Sid: ListExecutions
            Effect: Allow
            Action: states:ListExecutions
            Resource: "*"
          - Sid: TagGetResources
            Effect: Allow
            Action: tag:GetResources
            Resource: "*"

  GetStepFunctionExecutionTimeRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: Get-StepFunction-Execution-time
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - !Ref GetStepFunctionExecutionTimePolicy

  GetStepFunctionExecutionTimeLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${GetStepFunctionExecutionTimeFunction}
      RetentionInDays: 30

  GetStepFunctionExecutionTimeFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: Get-StepFunction-Execution-time
      Role: !GetAtt GetStepFunctionExecutionTimeRole.Arn
      Runtime: python3.13
      Handler: index.lambda_handler
      Architectures:
        - x86_64
      Timeout: !Ref LambdaTimeoutSeconds
      MemorySize: !Ref LambdaMemorySize
      Code:
        ZipFile: |
          import os
          import json
          import time
          import logging
          from typing import Dict, List
          from datetime import datetime, timezone

          import boto3
          import urllib.request
          import urllib.error

          # ====== 必要なグローバル変数 ======
          DD_SITE = os.environ.get("DD_SITE", "datadoghq.com").strip()
          DD_API_URL = f"https://api.{DD_SITE}/api/v1/series"
          METRIC_NAME = "custom.sfn.elapsed.seconds"

          MAX_RESULTS = int(os.environ.get("MAX_RESULTS", "1000"))  # list_executions のページサイズ
          ALLOWED_PROJECTS = {"Nest", "Arc"}
          DD_DEBUG_LOG = os.environ.get("DD_DEBUG_LOG", "false").lower() == "true"
          SET_UNIT_SECOND = os.environ.get("SET_UNIT_SECOND", "false").lower() == "true"
          DD_APP_KEY = os.environ.get("DD_APP_KEY")  # 単位設定に使用（任意）
          # ==============================================

          # 固定タグキー
          PROJECT_TAG_KEY = "Project"
          ENV_TAG_KEY = "Env"

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # AWS クライアント
          sfn = boto3.client("stepfunctions")
          rgtag = boto3.client("resourcegroupstaggingapi")

          # Datadog API Key は環境変数からのみ取得（追加の設定変数は作らない）
          def _load_dd_api_key() -> str:
              key = os.environ.get("DD_API_KEY")
              if not key:
                  raise RuntimeError("DD_API_KEY is required in environment variables")
              return key.strip()

          DD_API_KEY = _load_dd_api_key()

          def _norm_tag_value(v: str) -> str:
              return str(v).strip().replace(" ", "_")

          def _set_metric_unit_second_if_enabled() -> None:
              """任意：メトリクスの単位を 'second' に固定（1回成功すればOK）"""
              if not (SET_UNIT_SECOND and DD_APP_KEY):
                  return
              url = f"https://api.{DD_SITE}/api/v1/metrics/{METRIC_NAME}"
              body = json.dumps({"type": "gauge", "unit": "second"}).encode("utf-8")
              headers = {
                  "Content-Type": "application/json",
                  "DD-API-KEY": DD_API_KEY,
                  "DD-APPLICATION-KEY": DD_APP_KEY,
              }
              try:
                  req = urllib.request.Request(url, data=body, headers=headers, method="PUT")
                  with urllib.request.urlopen(req, timeout=8) as resp:
                      if DD_DEBUG_LOG:
                          logger.info(f"Datadog PUT unit {resp.getcode()}")
              except Exception as e:
                  logger.warning(f"Set unit failed (non-fatal): {e}")

          _set_metric_unit_second_if_enabled()

          def dd_post(series: List[Dict], max_retries: int = 3) -> None:
              """Datadog Metrics API へ送信（429/5xx リトライ）"""
              if not series:
                  return
              payload = json.dumps({"series": series}).encode("utf-8")
              headers = {"Content-Type": "application/json", "DD-API-KEY": DD_API_KEY}
              for attempt in range(max_retries):
                  req = urllib.request.Request(DD_API_URL, data=payload, headers=headers, method="POST")
                  try:
                      with urllib.request.urlopen(req, timeout=8) as resp:
                          code = resp.getcode()
                          body = resp.read().decode("utf-8", "ignore")
                          if DD_DEBUG_LOG:
                              logger.info(f"Datadog POST {code}: {body[:200]}")
                          if 200 <= code < 300:
                              return
                          raise urllib.error.HTTPError(req.full_url, code, f"HTTP {code}", resp.headers, None)
                  except urllib.error.HTTPError as e:
                      if e.code == 429:
                          time.sleep(int(e.headers.get("Retry-After", "1")))
                      elif 500 <= e.code < 600:
                          time.sleep(2 ** attempt)
                      else:
                          logger.error(f"Datadog post failed: {e}")
                          raise
                  except Exception as e:
                      if attempt < max_retries - 1:
                          time.sleep(2 ** attempt)
                      else:
                          logger.error(f"Datadog post error: {e}")
                          raise

          def discover_state_machines() -> List[Dict[str, str]]:
              """Project=Nest/Arc の Step Functions をタグで自動検出 → [{arn,name,env}]"""
              out: List[Dict[str, str]] = []
              token = None
              tag_filters = [{"Key": PROJECT_TAG_KEY, "Values": sorted(ALLOWED_PROJECTS)}]
              while True:
                  kwargs = {"ResourceTypeFilters": ["states:stateMachine"], "TagFilters": tag_filters}
                  if token:
                      kwargs["PaginationToken"] = token
                  resp = rgtag.get_resources(**kwargs)
                  for m in resp.get("ResourceTagMappingList", []):
                      arn = m.get("ResourceARN")
                      if not arn:
                          continue
                      name = arn.split(":")[-1]
                      tags = {t.get("Key"): t.get("Value") for t in m.get("Tags", [])}
                      env = tags.get(ENV_TAG_KEY) or tags.get(ENV_TAG_KEY.lower()) or ""
                      out.append({"arn": arn, "name": name, "env": env})
                  token = resp.get("PaginationToken")
                  if not token:
                      break
              return out

          def max_elapsed_seconds(sm_arn: str, now: datetime) -> int:
              """RUNNING 実行の最大経過秒を返す"""
              max_elapsed = 0
              token = None
              while True:
                  kwargs = {"stateMachineArn": sm_arn, "statusFilter": "RUNNING", "maxResults": MAX_RESULTS}
                  if token:
                      kwargs["nextToken"] = token
                  resp = sfn.list_executions(**kwargs)
                  for ex in resp.get("executions", []):
                      elapsed = int((now - ex["startDate"]).total_seconds())
                      if elapsed > max_elapsed:
                          max_elapsed = elapsed
                  token = resp.get("nextToken")
                  if not token:
                      break
              return max_elapsed

          def handler(event, context):
              now = datetime.now(timezone.utc)
              ts = int(now.timestamp())
              series: List[Dict] = []

              targets = discover_state_machines()
              if DD_DEBUG_LOG:
                  logger.info(json.dumps({"discovered": len(targets)}))

              for sm in targets:
                  sm_arn = sm["arn"]
                  sm_name = sm["name"]
                  sm_env = sm.get("env", "")

                  tags = [f"state_machine:{sm_name}"]
                  if sm_env:
                      tags.append(f"env:{_norm_tag_value(sm_env)}")

                  value = max_elapsed_seconds(sm_arn=sm_arn, now=now)

                  series.append({
                      "metric": METRIC_NAME,
                      "type": "gauge",
                      "points": [[ts, value]],
                      "tags": tags,
                  })

                  if DD_DEBUG_LOG:
                      logger.info(json.dumps({
                          "stateMachine": sm_name,
                          "env": sm_env or None,
                          "elapsed_max": value
                      }, ensure_ascii=False))

              dd_post(series)
              return {"ok": True, "series": len(series)}

          # 既定の lambda_function.lambda_handler にも対応
          def lambda_handler(event, context):
              return handler(event, context)
      Environment:
        Variables:
          DD_API_KEY: !Ref DatadogApiKey
          DD_DEBUG_LOG: !Ref DatadogDebugLog
          DD_SITE: !Ref DatadogSite
          SET_UNIT_SECOND: !Ref SetUnitSecond
          MAX_RESULTS: !Ref MaxExecutionsPageSize
          METRIC_NAME: custom.sfn.elapsed.seconds
          PROJECT_TAG_KEY: Project
          ENV_TAG_KEY: Env
          ALLOWED_PROJECTS: "Nest,Arc"

  GetStepFunctionExecutionTimeSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: Get-StepFunction-Execution-time
      Description: Invoke Get-StepFunction-Execution-time Lambda every 5 minutes
      ScheduleExpression: rate(5 minutes)
      State: ENABLED
      Targets:
        - Arn: !GetAtt GetStepFunctionExecutionTimeFunction.Arn
          Id: TargetLambda

  AllowEventsToInvokeLambda:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref GetStepFunctionExecutionTimeFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt GetStepFunctionExecutionTimeSchedule.Arn

Outputs:
  LambdaFunctionArn:
    Description: ARN of the Get-StepFunction-Execution-time Lambda
    Value: !GetAtt GetStepFunctionExecutionTimeFunction.Arn
  EventRuleArn:
    Description: ARN of the EventBridge schedule rule
    Value: !GetAtt GetStepFunctionExecutionTimeSchedule.Arn
  RoleArn:
    Description: IAM role used by the Lambda function
    Value: !GetAtt GetStepFunctionExecutionTimeRole.Arn
  ManagedPolicyArn:
    Description: Managed policy granting Step Functions/Tagging permissions
    Value: !Ref GetStepFunctionExecutionTimePolicy